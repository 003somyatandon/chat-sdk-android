package com.braunster.chatsdk.dao.core;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.braunster.chatsdk.dao.BLinkData;
import com.braunster.chatsdk.dao.BLinkedContact;
import com.braunster.chatsdk.dao.BMessage;
import com.braunster.chatsdk.dao.BMetadata;
import com.braunster.chatsdk.dao.BThread;
import com.braunster.chatsdk.dao.BThreadDao;
import com.braunster.chatsdk.dao.BUser;
import com.braunster.chatsdk.dao.BUserDao;
import com.braunster.chatsdk.dao.DaoMaster;
import com.braunster.chatsdk.dao.DaoSession;
import com.braunster.chatsdk.dao.entities.Entity;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

import de.greenrobot.dao.Property;
import de.greenrobot.dao.query.QueryBuilder;


/**
 * Manage all creation, deletion and updating Entities.
 */
public class DaoCore {
    private static final String TAG = DaoCore.class.getSimpleName();
    private static final boolean DEBUG = true;
    private static final String DB_NAME = "andorid-chatsdk-database";
    private static String dbName;

    public static final int ORDER_ASC = 0;
    public static final int ORDER_DESC = 1;

    private static Context context;

    private static DaoMaster.DevOpenHelper helper;
    private static SQLiteDatabase db;
    private static DaoMaster daoMaster;
    private static DaoSession daoSession;

    /** The property of the "EntityID" of the saved object. This entity comes from the server, For example Firebase server save Entities id's with an Char and Integers sequence.
     * The link between Entities in the databse structure is based on a long id generated by the database automatically.
     * To obtain an Entity using his server id we have to user this property.
     * Each Entity generates its own EntityID property so its very important to save the property id as the first property right after the long id property.
     * A workaround this is available by Checking for certain classes and use a different property for this class.*/
    public final static Property EntityID = new Property(1, String.class, "entityID", false, "ENTITY_ID");

    public static void init(Context ctx) {
        if (DEBUG) Log.i(TAG, "Initialized");
        dbName = DB_NAME;
        context = ctx;
        openDB();
        test();
    }

    public static void init(Context ctx, String databaseName){
        context = ctx;
        dbName = databaseName;
        openDB();
    }

    private static void openDB(){
        if (context == null)
            throw new NullPointerException("Context is null, Did you initialized DaoCore?");

        helper = new DaoMaster.DevOpenHelper(context, dbName, null);
        db = helper.getWritableDatabase();
        daoMaster = new DaoMaster(db);
        daoSession = daoMaster.newSession();
    }

    //region Test
    private static void test(){
        clearTestData();
//        printUsersData(daoSession.loadAll(BUser.class));
    }

    public static void printUsersData(){
        printUsersData(daoSession.loadAll(BUser.class));
    }

    public static void clearTestData(){
        daoSession.getBUserDao().deleteAll();
        daoSession.getBMessageDao().deleteAll();
        daoSession.getBThreadDao().deleteAll();
        daoSession.getBMetadataDao().deleteAll();
        daoSession.getBLinkedAccountDao().deleteAll();
        daoSession.getBLinkedContactDao().deleteAll();
        daoSession.getBLinkDataDao().deleteAll();
    }

    public static void createTestData(){

        // So we wont recreate the test again when app get killed by the System.
        BUser tmp = fetchEntityWithProperty(BUser.class, BUserDao.Properties.Name, "Dan");
        if (tmp != null)
        {
//            BLinkedContact linkedContact;
//            BUser us;
//            for (int i = 0 ; i < 50; i++) {
//                us = new BUser();
//                us.setEntityID(generateEntity());
//                us.setName("YOYOYOYO");
//                us.hasApp = true;
//                us.setOnline(true);
//                us.pictureExist = true;
//                us.pictureURL = "http://www.thedrinksbusiness.com/wordpress/wp-content/uploads/2012/05/Brad.jpg";
//                createEntity(us);
//
//
//                linkedContact = new BLinkedContact();
//                linkedContact.setEntityId(tmp.getEntityID());
//                linkedContact.setOwner(us.getEntityID());
//                DaoCore.createEntity(linkedContact);
//            }
                return;
        }

        BUser userDan = null, userAlex = null;
        try {
            userDan = new BUser();
            userDan.setName("Dan");
            userDan.setLastOnline(new Date(System.currentTimeMillis()));
            userDan.setEntityID(generateEntity());
            createEntity(userDan);

            userAlex = new BUser();
            userAlex.setName("Alex");
            userAlex.setLastOnline(new Date(System.currentTimeMillis()));
            userAlex.setEntityID(generateEntity());
            createEntity(userAlex);

            BMetadata bMetadata, bMetadata1;

            String[] key = new String[]{"Country" , "Gender", "Age", "FootballTeam", "NationalTeam"};
            String[] values = new String[]{"Israel" , "Male", "23", "Juventus", "Italy"};

            String[] key1 = new String[]{"Country" , "Gender", "Age", "FootballTeam", "NationalTeam"};
            String[] values1 = new String[]{"Germany" , "Male", "26", "Herta Berlin", "Germany"};

            for (int i = 0 ; i < 5 ; i++)
            {
                bMetadata = new BMetadata();
                bMetadata.setOwnerID(userDan.getId());
                bMetadata.setType(BMetadata.Type.STRING);
                bMetadata.setKey(key[i]);
                bMetadata.setValue(values[i]);
                createEntity(bMetadata);

                bMetadata1 = new BMetadata();
                bMetadata1.setOwnerID(userAlex.getId());
                bMetadata1.setType(BMetadata.Type.STRING);
                bMetadata1.setKey(key1[i]);
                bMetadata1.setValue(values1[i]);
                createEntity(bMetadata1);
            }


            BUser user = new BUser();
            user.setEntityID(DaoCore.generateEntity());
            user.setName("Bob");
            user.hasApp = true;
            user.setOnline(true);
            user.pictureExist = true;
            user.pictureURL = "http://www.thedrinksbusiness.com/wordpress/wp-content/uploads/2012/05/Brad.jpg";

            BUser user1 = new BUser();
            user1.setEntityID(DaoCore.generateEntity());
            user1.setName("Giorgio");
            user1.hasApp = true;
            user1.setOnline(false);
            user1.pictureExist = true;
            user1.pictureURL = "http://www.insidespanishfootball.com/wp-content/uploads/2013/07/Cheillini-300x203.jpg";

            BUser user2 = new BUser();
            user2.setEntityID(DaoCore.generateEntity());
            user2.setName("Claudio");
            user2.setOnline(false);
            user2.hasApp = true;
            user2.pictureExist = true;
            user2.pictureURL = "http://www.affashionate.com/wp-content/uploads/2013/04/Claudio-Marchisio-season-2012-2013-claudio-marchisio-32347274-741-1024.jpg";

            BUser user3 = new BUser();
            user3.setEntityID(DaoCore.generateEntity());
            user3.setName("John");
            user3.hasApp = true;
            user3.setOnline(true);
            user3.pictureExist = true;
            user3.pictureURL = "http://images2.alphacoders.com/249/249012.jpg";

            DaoCore.createEntity(user);
            DaoCore.createEntity(user1);
            DaoCore.createEntity(user2);
            DaoCore.createEntity(user3);

            BLinkedContact linkedContact = new BLinkedContact();
            linkedContact.setEntityID(userDan.getEntityID());
            linkedContact.setOwner(user.getId());
            DaoCore.createEntity(linkedContact);

            BLinkedContact linkedContact1 = new BLinkedContact();
            linkedContact1.setEntityID(userDan.getEntityID());
            linkedContact1.setOwner(user1.getId());
            DaoCore.createEntity(linkedContact1);

            BLinkedContact linkedContact2 = new BLinkedContact();
            linkedContact2.setEntityID(userDan.getEntityID());
            linkedContact2.setOwner(user2.getId());
            DaoCore.createEntity(linkedContact2);

            BLinkedContact linkedContact3 = new BLinkedContact();
            linkedContact3.setEntityID(userDan.getEntityID());
            linkedContact3.setOwner(user3.getId());
            DaoCore.createEntity(linkedContact3);

            int t = 9;
            BThread thread;
            String [] threadNames = new String[] { "Work", "Family", "Party", "Serie A", "World Cup", "School", "Army Friends", "JCI"};
            int [] threadType = new int[] { 0, 0, 1, 1, 1, 0, 0, 0};
            BLinkData linkData;

            for (int i = 0; i < t; i++) {

                thread = new BThread();
                thread.setEntityID(generateEntity());
                thread.setType(threadType[i]);
                thread.setName(threadNames[i]);
                thread.setCreator(i % 2 == 0 ? userDan : userAlex);
                createEntity(thread);

                //region LinkData
                linkData = new BLinkData();
                linkData.setEntityID(generateEntity());
                linkData.setThreadID(thread.getId());
                linkData.setUserID(userDan.getId());

                createEntity(linkData);

                linkData = new BLinkData();
                linkData.setEntityID(generateEntity());
                linkData.setThreadID(thread.getId());
                linkData.setUserID(userAlex.getId());

                createEntity(linkData);
                //endregion

                BMessage message;
                for (int j = 0; j < 7; j++) {
                    message = new BMessage();
                    message.setEntityID(generateEntity());
                    message.setOwnerThread(thread.getId());
                    message.setText(generateEntity());
                    message.setDate(new Date(System.currentTimeMillis()));
                    message.setType(BMessage.Type.bText.ordinal());
                    message.setSender(j % 2 == 0 ? userDan.getId() : userAlex.getId());
                    createEntity(message);
                }
            }

        } catch (RuntimeException e) {
            e.printStackTrace();
        }
    }

    private static void getTestData(){
        //region Description
/*        QueryBuilder<BUser> queryBuilder = daoSession.queryBuilder(BUser.class);
        BUser bUser = queryBuilder.where(BUserDao.Properties.EntityID .eq("asdasdas54d5a")).unique();

        if (bUser == null)
        {
            Log.d(TAG, "user is null");
            bUser = queryBuilder.where(BUserDao.Properties.Name .eq("Dan")).unique();
        }

        if (bUser == null)
        {
            Log.d(TAG, "user is null");
        }
        else
        {
            Log.d(TAG, "has user");
        }*/
        //endregion

        printUsersData(daoSession.loadAll(BUser.class));
    }

    private static void printUsersData(List<BUser> users){
        if (DEBUG) Log.v(TAG, "PrintUserData: " + users.size());
        for (BUser u : users)
        {
            if (u == null)
                Log.d(TAG, "user is null");
            else
            {
                Log.i(TAG, "--------------------User--------------------");
                printEntity(u);

                Log.i(TAG, "Contacts Amount: " + u.getContacts().size());
                for (BUser c : u.getContacts())
                    printEntity(c);

                Log.i(TAG, "Metadata Size: " + u.getMetadata().size());
                for (BMetadata m : u.getMetadata())
                {
                    printEntity(m);
                }
                Log.i(TAG, "Threads Size: "  + u.getThreads().size());

                for (BThread t : u.getThreads())
                {
                    printEntity(t);

                    for (BMessage m : t.getMessages())
                        printEntity(m);
                }
                Log.i(TAG, "Messages Amount: " + u.getMessages().size());
            }
        }
    }

    private static void getTestData2(){
        List<BUser> list = fetchEntitiesWithProperty(BUser.class, BUserDao.Properties.Name, "Dan");
        printUsersData(list);
        BThread thread = fetchEntityWithEntityID(BThread.class, "asdasda");
        List<BThread> threads = fetchEntitiesWithProperty(BThread.class, BThreadDao.Properties.Type, "0");
    }

    public static String generateEntity() {
        return new BigInteger(130, new Random()).toString(32);
    }
    //endregion

    /** Fetch entity for fiven entity ID, If more then one found the first will be returned.*/
    public static <T extends Entity<T>> T fetchEntityWithEntityID(Class c, Object entityID){
        return fetchEntityWithProperty(c, EntityID, entityID);
    }

    /** Fetch Buser object For given AuthenticationID, If more then one found the first will be returned.*/
    public static <T extends Entity<T>> T fetchUserWithAuthID(Object authId){
        return fetchEntityWithProperty(BUser.class, BUserDao.Properties.AuthenticationId, authId);
    }

    /** Fetch an entity for given property and value. If more then one found the first will be returned.*/
    public static <T extends Entity<T>> T fetchEntityWithProperty(Class c, Property property,Object value){
        QueryBuilder qb = daoSession.queryBuilder(c);
        qb.where(property.eq(value));

        List<Entity> list = (List<Entity>) qb.list();
        if (list != null && list.size()>0)
            return (T) list.get(0) ;
        else return null;
    }

    /** Fetch a list of entities for a given property and value.*/
    public static <T extends Entity<T>> List<T> fetchEntitiesWithProperty(Class c, Property property, Object value){
        return fetchEntitiesWithPropertyAndOrder(c, null, -1, property, value);
    }

    /** Fetch a list of entities for a given properties and values.*/
    public static <T extends Entity<T>> List<T> fetchEntitiesWithProperties(Class c, Property properties[], Object... values){
        return fetchEntitiesWithPropertiesAndOrder(c, null, -1, properties, values);
    }

    /** Fetch a list of entities for a given property and value. Entities are arrange by given order.*/
    public static <T extends Entity<T>> List<T> fetchEntitiesWithPropertyAndOrder(Class c, Property whereOrder, int order, Property property, Object value){
        return fetchEntitiesWithPropertiesAndOrder(c, whereOrder, order, new Property[]{property}, value);
    }

    public static <T extends Entity<T>> List<T>  fetchEntitiesWithPropertiesAndOrder(Class c, Property whereOrder, int order, Property properties[], Object... values){

        if (values == null || properties == null)
            throw new NullPointerException("You must have at least one value and one property");

        if (values.length != properties.length)
            throw new IllegalArgumentException("Values size should match properties size");

        QueryBuilder qb = daoSession.queryBuilder(c);
        qb.where(properties[0].eq(values[0]));

        if (values.length > 1)
            for (int i = 0 ; i < values.length ; i++)
                qb.where(properties[i].eq(values[i]));

        if (whereOrder != null && order != -1)
            switch (order)
            {
                case ORDER_ASC:
                    qb.orderAsc(whereOrder);
                    break;

                case ORDER_DESC:
                    qb.orderDesc(whereOrder);
                    break;
            }


        return qb.list();
    }

    public static <T extends Entity<T>> List<T>  fetchEntitiesWithPropertiesAndOrderAndLimit(Class c, int limit, Property whereOrder, int order, Property properties[], Object... values){

        if (values == null || properties == null)
            throw new NullPointerException("You must have at least one value and one property");

        if (values.length != properties.length)
            throw new IllegalArgumentException("Values size should match properties size");

        QueryBuilder qb = daoSession.queryBuilder(c);
        qb.where(properties[0].eq(values[0]));

        if (values.length > 1)
            for (int i = 0 ; i < values.length ; i++)
                qb.where(properties[i].eq(values[i]));

        if (whereOrder != null && order != -1)
            switch (order)
            {
                case ORDER_ASC:
                    qb.orderAsc(whereOrder);
                    break;

                case ORDER_DESC:
                    qb.orderDesc(whereOrder);
                    break;
            }

        if (limit != -1)
            qb.limit(limit);

        return qb.listLazy();
    }

    public static BUser fetchOrCreateUserWithEntityAndAutID(String entityId, String authenticationID){
        if(DEBUG) Log.v(TAG, "fetchOrCreateUserWithEntityAndAutID, AuthID: " + authenticationID + ", EntityID: " + entityId);

        List<BUser> users = new ArrayList<BUser>();

        if (entityId != null && authenticationID != null && !entityId.equals("") && !authenticationID.equals("")){
//            users  = fetchEntitiesWithProperties(BUser.class,
//                    new Property[]{BUserDao.Properties.EntityID, BUserDao.Properties.AuthenticationId},
//                    entityId, authenticationID);

            // Try fetching with auth id if can't try with entityID.
            users = fetchEntitiesWithProperty(BUser.class, BUserDao.Properties.AuthenticationId, authenticationID);
            if ( users == null || users.size() == 0)
                users = fetchEntitiesWithProperty(BUser.class, BUserDao.Properties.EntityID, entityId);
        }
        else
        {
            if (entityId != null && !entityId.equals(""))
            {
                if (DEBUG) Log.d(TAG, "Fetching based on entityID");
                users = fetchEntitiesWithProperty(BUser.class, BUserDao.Properties.EntityID, entityId);
            }
            else if (authenticationID != null && !authenticationID.equals(""))
            {
                if (DEBUG) Log.d(TAG, "Fetching based on facebookID");
                users = fetchEntitiesWithProperty(BUser.class, BUserDao.Properties.AuthenticationId, authenticationID);
            }
        }

        BUser user = null;

        if (DEBUG) Log.d(TAG, "fetchOrCreateUserWithEntityAndAutID, UsersAmount: " + (users != null ? users.size() : "No User Found."));

        if (users == null || users.size() == 0)
        {
            if (DEBUG) Log.d(TAG, "creating new entity");
            user = new BUser();
            user.setEntityID(entityId);
            user.setAuthenticationId(authenticationID);
            createEntity(user);
            return user;
        }
        // updating the entity with the given authId and EntityId
        else
        {
            users.get(0).setEntityID(entityId);
            users.get(0).setAuthenticationId(authenticationID);
            updateEntity(users.get(0));
        }

        // It's possible that we could get multiple user records some registered
        // with a Facebook ID and some with a Firebase ID so we'll merge the records here
        return users.get(0);
    }

    public static BUser fetchOrCreateUserWithAuthinticationID(String authinticationID){
        if (authinticationID == null)
            return null;

        BUser user = fetchUserWithAuthID(authinticationID);

        if (user == null)
        {
            user = new BUser();
            user.setAuthenticationId(authinticationID);
            createEntity(user);
        }

        return user;
    }

    public static <T extends Entity> T fetchOrCreateEntityWithEntityID(Class c, String entityId){
        if (DEBUG) Log.v(TAG, "fetchOrCreateEntityWithEntityID, EntityID: " + entityId);

        Entity entity = fetchEntityWithEntityID(c, entityId);

        if (entity == null)
        {
            entity = getEntityForClass(c);

            entity.setEntityID(entityId);

            createEntity(entity);
        }

        return (T) entity;
    }

    /** Fetch an Entity for given property and class.
     * If no Entity found a new one will be created.
     * The calling method have to handle the the inserting
     * of the given value if a new Entity was created.
     *
     * @return and object that Extends the Entity object.
     * The object will be created from the given class.*/
    private static <T extends Entity> T fetchOrCreateEntityWithProperty(Class c, Property property, Object value){
        if (DEBUG) Log.v(TAG, "fetchOrCreateEntityWithProperty, Value: " + value);
        Entity entity = fetchEntityWithProperty(c, property, value);

        if (entity != null)
            return (T) entity;

        // Create the new entity.
        Class<?> clazz = null;
        Object o = null;
        try {
            clazz = Class.forName(c.getName());
            Constructor<?> ctor = clazz.getConstructor();
            o = ctor.newInstance();
        } catch (ClassNotFoundException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "ClassNotFoundException");
        } catch (NoSuchMethodException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "NoSuchMethodException");
        } catch (InvocationTargetException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "InvocationTargetException");
        } catch (InstantiationException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "InstantiationException");
        } catch (IllegalAccessException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "IllegalAccessException");
        }

        if (o != null)
        {
            if (DEBUG) Log.d(TAG, "Returning new entity");
            return (T) createEntity((Entity) o);
        }

        return null;
    }

    /* Update, Create and Delete*/
    public static  <T extends Entity> T createEntity(T entity){
        Log.v(TAG, "createEntity");

        if (entity == null)
        {
            if (DEBUG) Log.e(TAG, "Entity is null");
            return null;
        }

        daoSession.insert(entity);

        if(DEBUG) printEntity(entity);

        return entity;
    }

    public static <T extends Entity> T deleteEntity(T entity){
        Log.v(TAG, "deleteEntity");

        if(DEBUG) printEntity(entity);

        daoSession.delete(entity);

        return entity;
    }

    public static <T extends Entity> T updateEntity(T entity){
        Log.v(TAG, "updateEntity");

        printEntity(entity);

        daoSession.update(entity);

        return entity;
    }

    /* Helpers */
    public static void printEntity(Entity entity){
        Log.v(TAG, "printEntity");

        Log.i(TAG, "id:" + entity.getId());
        Log.i(TAG, "Entity id:" + (entity.getEntityID() != null ? entity.getEntityID() : "null") );
        Log.i(TAG, "Entity Class:" + entity.getClass());

        try {
            // Print user details.
            if (entity.getClass().equals(BUser.class))
            {
                Log.i(TAG, "Auth ID: " + ((BUser) entity).getAuthenticationId());
                Log.i(TAG, "Name: " + ((BUser) entity).getMetaName());
                Log.i(TAG, "Online: " + ((BUser) entity).getOnline());
                Log.i(TAG, "FontName: " + ((BUser) entity).getFontName());
                Log.i(TAG, "FontSize: " + ((BUser) entity).getFontSize());
                Log.i(TAG, "MessageColor: " + ((BUser) entity).getMessageColor());
                Log.i(TAG, "TextColor: " + ((BUser) entity).getTextColor());
            }
            else if (entity.getClass().equals(BMetadata.class))
            {
                Log.i(TAG, "Owner ID: " + ((BMetadata) entity).getOwnerID());
                Log.i(TAG, "Key: " + ((BMetadata) entity).getKey());
                Log.i(TAG, "Value: " + ((BMetadata) entity).getValue());
                Log.i(TAG, "Type: " + ((BMetadata) entity).getType());
            }
            else if (entity.getClass().equals(BThread.class))
            {
                Log.i(TAG, "Name: " + ((BThread) entity).getName());
                Log.i(TAG, "Display Name: " + ((BThread) entity).displayName());
                Log.i(TAG, "Creation Date: " + ((BThread)entity).getCreationDate().getTime());
                Log.i(TAG, "Type: " + ( ((BThread) entity).getType() == 1 ? "Public" : "Private"));
                Log.i(TAG, "Messages Amount: " + ((BThread) entity).getMessages().size());
            }
            else if (entity.getClass().equals(BMessage.class))
            {
                Log.i(TAG, "Text: " + ((BMessage) entity).getText());
                Log.i(TAG, "Thread id: " + ((BMessage) entity).getOwnerThread());
                Log.i(TAG, "Sender id: " + ((BMessage) entity).getSender());
                Log.i(TAG, "Thread Entity Id: " + ((BMessage) entity).getBThreadOwner().getEntityID());
                Log.i(TAG, "Sender Entity Id: " + ((BMessage) entity).getBUserSender().getEntityID());
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }

    public static void connectUserAndThread(BUser user, BThread thread){
        Log.v(TAG, "connectUserAndThread, User ID: " + user.getId() + ", Name: " + user.getMetaName() + ", Thread ID: " + thread.getId());
        BLinkData linkData = new BLinkData();
        linkData.setThreadID(thread.getId());
        linkData.setUserID(user.getId());
        createEntity(linkData);
    }

    private static Entity getEntityForClass(Class c){
        // Create the new entity.
        Class<?> clazz = null;
        Object o = null;
        try {
            clazz = Class.forName(c.getName());
            Constructor<?> ctor = clazz.getConstructor();
            o = ctor.newInstance();
        } catch (ClassNotFoundException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "ClassNotFoundException");
        } catch (NoSuchMethodException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "NoSuchMethodException");
        } catch (InvocationTargetException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "InvocationTargetException");
        } catch (InstantiationException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "InstantiationException");
        } catch (IllegalAccessException e) {
//                e.printStackTrace();
            if (DEBUG) Log.e(TAG, "IllegalAccessException");
        }

        return (Entity) o;
    }
/*    private static <T extends Entity> T merge(List<T> entities){

        T tmp = null;

        if (entities == null)
        {
            return null;
        }
        if (entities.size() == 1)
        {
            return entities.get(0);
        }
        if (entities.size() > 1)
        {
            // It's possible that we could get multiple user records some registered
            // with a Facebook ID and some with a Firebase ID so we'll merge the records here
            tmp = entities.get(0);

            for (T t : entities)
            {
                if (!t.equals(tmp))
                {
                    tmp.updateFrom(t);
                    deleteEntity(t);
                }
            }

            updateEntity(tmp);

            return tmp;
        }

        return null;
    }*/
}
